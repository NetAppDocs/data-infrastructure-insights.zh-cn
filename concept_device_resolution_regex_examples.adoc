---
sidebar: sidebar 
permalink: concept_device_resolution_regex_examples.html 
keywords: Automatic, AR, AHR, Host, automatic device resolution, FC, Identify, regex, expressions 
summary:  
---
= 正则表达式示例
:hardbreaks:
:allow-uri-read: 


[role="lead"]
如果您选择正则表达式方法作为源命名策略，则可以使用正则表达式示例作为Data Infrastructure Insights自动解析方法中使用的表达式的指南。



== 格式化正则表达式

在为Data Infrastructure Insights自动解析创建正则表达式时，您可以通过在名为 _FORMAT_ 的字段中输入值来配置输出格式。

默认设置为 \1，这意味着与正则表达式匹配的区域名称将被正则表达式创建的第一个变量的内容替换。在正则表达式中，变量值由括号语句创建。如果出现多个括号语句，则变量按从左到右的数字方式引用。变量可以在输出格式中以任意顺序使用。通过将常量文本添加到 FORMAT 字段，也可以将其插入到输出中。

例如，对于此区域命名约定，您可能具有以下区域名称：

 [Zone number]_[data center]_[hostname]_[device type]_[interface number]
* S123_Miami_hostname1_filer_FC1
* S14_Tampa_hostname2_switch_FC4
* S3991_Boston_hostname3_windows2K_FC0
* S44_Raleigh_hostname4_solaris_FC1


您可能希望输出采用以下格式：

 [hostname]-[data center]-[device type]
为此，您需要捕获变量中的主机名、数据中心和设备类型字段，并在输出中使用它们。以下正则表达式可以实现此目的：

 .*?_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_.*
因为有三组括号，所以变量 \1、\2 和 \3 将被填充。

然后，您可以使用以下格式来接收您喜欢的格式的输出：

 \2-\1-\3
您的输出如下：

....
hostname1-Miami-filer
hostname2-Tampa-switch
hostname3-Boston-windows2K
hostname4-Raleigh-solaris
....
变量之间的连字符提供了插入格式化输出中的常量文本的示例。



== 示例



=== 示例 1 显示区域名称

在此示例中，您使用正则表达式从区域名称中提取主机名。如果您有类似于以下区域名称的内容，则可以创建正则表达式：

* S0032_myComputer1Name-HBA0
* S0434_myComputer1Name-HBA1
* S0432_myComputer1Name-HBA3


可以用来捕获主机名的正则表达式是：

 S[0-9]+_([a-zA-Z0-9]*)[_-]HBA[0-9]
结果是匹配所有以 S 开头的区域，后跟任意数字组合，再后跟下划线、字母数字主机名（myComputer1Name）、下划线或连字符、大写字母 HBA 和单个数字（0-9）。主机名单独存储在 *\1* 变量中。

正则表达式可以分解成以下几个部分：

* “S”代表区域名称并开始表达式。这仅匹配区域名称开头的“S”。
* 括号中的字符 [0-9] 表示“S”后面必须是 0 到 9 之间的数字（包括 0 和 9）。
* +号表示前面括号中的信息必须出现1次或多次。
* _（下划线）表示区域名称中 S 后面的数字后面必须紧跟一个下划线字符。在此示例中，区域命名约定使用下划线将区域名称与主机名分开。
* 在必需的下划线之后，括号表示其中包含的模式将存储在 \1 变量中。
* 括号中的字符[a-zA-Z0-9]表示匹配的字符全部为字母（不区分大小写）和数字。
* 括号后面的 *（星号）表示括号内的字符出现 0 次或多次。
* 括号中的字符 [_-]（下划线和破折号）表示字母数字模式后面必须跟下划线或破折号。
* 正则表达式中的字母 HBA 表示区域名称中必须出现此精确的字符序列。
* 最后一组括号内的字符 [0-9] 匹配从 0 到 9（含）的单个数字。




=== 示例 2

在这个例子中，跳到第一个下划线“_”，然后匹配 E 和其后的所有内容直到第二个“_”，然后跳过其后的所有内容。

*区域：* Z_E2FHDBS01_E1NETAPP

*主机名：*E2FHDBS01

*正则表达式：*.*?_(E.*?)_.*?



=== 示例 3

正则表达式（如下）中最后一部分的括号“（）”标识哪部分是主机名。如果您希望 VSAN3 作为主机名，则其名称为：[a-zA-Z0-9]+_([a-zA-Z0-9]+)。*

*区域：*A_VSAN3_SR48KENT_A_CX2578_SPA0

*主机名：*SR48KENT

*正则表达式：* [a-zA-Z0-9]+_[a-zA-Z0-9]+_([a-zA-Z0-9]+).*



=== 示例 4 展示了更复杂的命名模式

如果您有类似于以下区域名称的内容，则可以创建正则表达式：

* myComputerName123-HBA1_Symm1_FA3
* myComputerName123-HBA2_Symm1_FA5
* myComputerName123-HBA3_Symm1_FA7


可以用来捕获这些内容的正则表达式是：

 ([a-zA-Z0-9]*)_.*
经过此表达式评估后，\1 变量将仅包含 _myComputerName123_。

正则表达式可以分解成以下几个部分：

* 括号表示其中包含的模式将存储在 \1 变量中。
* 括号中的字符 [a-zA-Z0-9] 表示任何字母（无论大小写）或数字都会匹配。
* 括号后面的 *（星号）表示括号内的字符出现 0 次或多次。
* 正则表达式中的 _（下划线）字符表示区域名称必须在前面括号匹配的字母数字字符串后紧跟下划线。
* 这 。  （句点）匹配任何字符（通配符）。
* *（星号）表示前面的句点通配符可以出现 0 次或多次。
+
换句话说，组合 .* 表示任意字符、任意次数。





=== 示例 5 显示没有模式的区域名称

如果您有类似于以下区域名称的内容，则可以创建正则表达式：

* myComputerName_HBA1_Symm1_FA1
* myComputerName123_HBA1_Symm1_FA1


可以用来捕获这些内容的正则表达式是：

 (.*?)_.*
\1 变量将包含 _myComputerName_（在第一个区域名称示例中）或 _myComputerName123_（在第二个区域名称示例中）。因此，该正则表达式将匹配第一个下划线之前的所有内容。

正则表达式可以分解成以下几个部分：

* 括号表示其中包含的模式将存储在 \1 变量中。
* 这 。*  （句点星号）匹配任意字符，任意次数。
* 括号后面的 *（星号）表示括号内的字符出现 0 次或多次。
* ? 字符使匹配变得非贪婪。这会强制它在第一个下划线处停止匹配，而不是最后一个下划线。
* 字符 _.* 与找到的第一个下划线及其后面的所有字符匹配。




=== 示例 6 显示具有模式的计算机名称

如果您有类似于以下区域名称的内容，则可以创建正则表达式：

* Storage1_Switch1_myComputerName123A_A1_FC1
* Storage2_Switch2_myComputerName123B_A2_FC2
* Storage3_Switch3_myComputerName123T_A3_FC3


可以用来捕获这些内容的正则表达式是：

 .*?_.*?_([a-zA-Z0-9]*[ABT])_.*
因为区域命名约定具有更多的模式，我们可以使用上述表达式，它将匹配以 A、B 或 T 结尾的主机名（示例中的 myComputerName）的所有实例，并将该主机名放在 \1 变量中。

正则表达式可以分解成以下几个部分：

* 这 。*  （句点星号）匹配任意字符，任意次数。
* ? 字符使匹配变得非贪婪。这会强制它在第一个下划线处停止匹配，而不是最后一个下划线。
* 下划线字符与区域名称中的第一个下划线匹配。
* 因此，第一个 .*?_ 组合与第一个区域名称示例中的字符 Storage1_ 匹配。
* 第二个 .*?_ 组合的行为与第一个类似，但与第一个区域名称示例中的 Switch1_ 匹配。
* 括号表示其中包含的模式将存储在 \1 变量中。
* 括号中的字符 [a-zA-Z0-9] 表示任何字母（无论大小写）或数字都会匹配。
* 括号后面的 *（星号）表示括号内的字符出现 0 次或多次。
* 正则表达式 [ABT] 中的括号字符与区域名称中的单个字符匹配，该字符必须是 A、B 或 T。
* 括号后面的 _（下划线）表示 [ABT] 字符匹配后面必须跟一个下划线。
* 这 。*  （句点星号）匹配任意字符，任意次数。


因此，其结果将导致 \1 变量包含任何字母数字字符串：

* 前面是一些字母数字字符和两个下划线
* 后面跟着一个下划线（然后是任意数量的字母数字字符）
* 在第三个下划线之前，以 A、B 或 T 作为结尾字符。




=== 示例 7

*区域：*myComputerName123_HBA1_Symm1_FA1

*主机名：*myComputerName123

正则表达式：（[a-zA-Z0-9]+）_。



=== 示例 8

此示例查找第一个 _ 之前的所有内容。

区域：MyComputerName_HBA1_Symm1_FA1

MyComputerName123_HBA1_Symm1_FA1

主机名：MyComputerName

正则表达式：(.*?)_.*



=== 示例 9

此示例查找第一个 _ 之后到第二个 _ 的所有内容。

*区域：* Z_MyComputerName_StorageName

*主机名：*我的计算机名

*正则表达式：* .*?_(.*?)_.*?



=== 示例 10

此示例从区域示例中提取“MyComputerName123”。

*区域：*Storage1_Switch1_MyComputerName123A_A1_FC1

Storage2_Switch2_MyComputerName123B_A2_FC2

Storage3_Switch3_MyComputerName123T_A3_FC3

*主机名：*MyComputerName123

*正则表达式:* .*?_.*?_([a-zA-Z0-9]+)*[ABT]_.*



=== 示例 11

*区域：*Storage1_Switch1_MyComputerName123A_A1_FC1

*主机名：*MyComputerName123A

*正则表达式:* .*?_.*?_([a-zA-z0-9]+)_.*?_



=== 示例 12

方括号内的 ^（脱字符或插入符号）*用于对表达式进行否定，例如，[^Ff] 表示除大写或小写 F 之外的任何字符，[^az] 表示除小写 a 到 z 之外的所有内容，在上述情况下，表示除 _ 之外的任何字符。格式语句在输出主机名中添加“-”。

*区域：*mhs_apps44_d_A_10a0_0429

*主机名：*mhs-apps44-d

*正则表达式：* ([^_]+)_([AB]).*Data Infrastructure Insights中的格式：\1-\2 ([^_]+)_ ([^_]+)_([^_]+).*Data Infrastructure Insights中的格式：\1-\2-\3



=== 示例 13

在这个例子中，存储别名由“\”分隔，表达式需要使用“\\”来定义字符串中实际使用的“\”，并且它们不是表达式本身的一部分。

*存储别名：* \Hosts\E2DOC01C1\E2DOC01N1

*主机名：*E2DOC01N1

*正则表达式：* \\.*?\\.*?\\(.*?)



=== 示例 14

此示例从区域示例中提取“PD-RV-W-AD-2”。

*区域：*PD_D-PD-RV-W-AD-2_01

*主机名：*PD-RV-W-AD-2

正则表达式：[^-]+-(.*-\d+).*



=== 示例 15

在这种情况下，格式设置将“US-BV-”添加到主机名。

*区域：*SRV_USBVM11_F1

*主机名：*US-BV-M11

*正则表达式：*SRV_USBV([A-Za-z0-9]+)_F[12]

*格式：* US-BV-\1
